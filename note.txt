路由与导航
    基本路由
    子路由
    辅助路由
    路由守卫[canActivate, canDeactivate]
    resolve 路由

依赖注入
    什么是依赖注入(侧重于手段)
        类本身不创建对象, 由外部容器创建对象注入到本类中
    什么是控制反转(侧重与描述)(与依赖注入是一个思想)
        类本身不创建对象, 由外部容器创建对象注入到本类中
        这样对象的控制权就转移到了外部
    好处
        松耦合, 提高重用性

    Code
        /*
          两种写法功能是一样的
          providers: [ProductService]
          providers: [{provide: ProductService, useClass: AnotherProductService}]

          constructor(private productService: ProductService) {}
          // 1.从 providers 获取对应的 token (provide: ProductService)
          // 2.实例化 对应的对象 (useClass: AnotherProductService)
        */

    提供器的层级关系
        应用级提供器(模块中的 providers)
        组件级提供器(组件中的 providers)
        子组件级提供器

    组件获取提供器的顺序
        自身的 providers 中获取
        父组件的 providers 中获取
        应用级的 providers 中获取
            Injectable 装饰器会存储到应用级的 providers 中
            module 的 providers 会覆盖 Injectable 装饰器

        上面三层都没有获取到抛异常

数据绑定 响应式编程 管道
  数据绑定
    双大括号, 绑定元素的内容
    方括号, 绑定元素的标签
    小括号, 绑定元素的事件
        <input (change)="methodName($event)">
            change: 事件名称
            methodName: 组件的方法名称
        <button (click)="flag = false">

    DOM 属性和 HTML 属性的区别, 数据绑定绑定的是 DOM 属性
      DOM 属性, DOM 元素的属性
      HTML 属性, DOM 元素的 HTML 标签属性

  响应式编程
    const subscription = of(1, 2, 3, 4, 5)
      .pipe(
        filter(n => n % 2 === 0),
        map(n => n * n)
      )
      .subscribe({
        next: x => console.log(x),
        error: err => console.error(err),
        complete: () => console.log('ok')
      });

    - 可观察对象, 表示一组值或者事件的集合
      1, 2, 3, 4, 5
    - 观察者, 一个回调函数的集合, 他知道怎么样去监听 Observable 发送的值
      pipe
    - 观察对象, 表示一个观察对象, 用于取消观察
      subscription
    - 操作符, 纯粹的函数, 可以用函数是编程来处理集合
      filter
      map

  管道
    用于过滤数据
    
组件之间通讯

表单处理

与服务端通讯

构建与部署
